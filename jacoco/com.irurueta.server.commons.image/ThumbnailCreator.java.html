<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ThumbnailCreator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-server-commons-image</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.server.commons.image</a> &gt; <span class="el_source">ThumbnailCreator.java</span></div><h1>ThumbnailCreator.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.server.commons.image;

import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.lang.ref.SoftReference;
import javax.imageio.ImageIO;

/**
 * This class generates thumbnails of images.
 * Notice that this class can also be used to transcode images to other formats
 * when generating thumbnails (even if they have the same size as the original
 * image)
 */
public class ThumbnailCreator {
    /**
     * Minimum allowed image size.
     */
    public static final int MIN_SIZE = 0;
    
    /**
     * Default maximum number of concurrent threads that can generate a 
     * thumbnail at the same time.
     */
    public static final int DEFAULT_MAX_CONCURRENT_THREADS = 1;
    
    /**
     * Minimum number of concurrent threads that can generate a thumbnail at the
     * same time.
     */
    public static final int MIN_CONCURRENT_THREADS = 1;
    
    /**
     * Reference to singleton instance of thumbnail creator.
     */
<span class="fc" id="L55">    private static SoftReference&lt;ThumbnailCreator&gt; mReference = null;</span>
    
    /**
     * Maximum number of threads that can generate a thumbnail at the same time.
     * To avoid excessive memory usage, the number of concurrent thumbnails
     * being generated is limited to this value.
     * By default only one thread can generate thumbnails concurrently while
     * other threads will wait until they are allowed.
     * If the server has enough memory and its load is not too high, this value
     * can be increased (especially if the hardware architecture has multiple
     * processors). Increasing this value will result in a larger throughput of
     * generated thumbnails, at the expense of a greater memory usage.
     */
    private int mMaxConcurrentThreads;
    
    /**
     * Current number of threads generating a thumbnail.
     */
    private volatile int mNumThreads;
    
    /**
     * Constructor.
     */
<span class="fc" id="L78">    private ThumbnailCreator() {</span>
        //TODO: make maximum number of concurrent threads configurable
<span class="fc" id="L80">        mMaxConcurrentThreads = DEFAULT_MAX_CONCURRENT_THREADS;</span>
<span class="fc" id="L81">        mNumThreads = 0;</span>
<span class="fc" id="L82">    }</span>
    
    /**
     * Factory method. Creates or returns the singleton instance of this class
     * @return singleton.
     */
    public synchronized static ThumbnailCreator getInstance() {
        ThumbnailCreator creator;
<span class="pc bpc" id="L90" title="1 of 4 branches missed.">        if (mReference == null || (creator = mReference.get()) == null) {</span>
<span class="fc" id="L91">            creator = new ThumbnailCreator();</span>
<span class="fc" id="L92">            mReference = new SoftReference&lt;&gt;(creator);</span>
        }
<span class="fc" id="L94">        return creator;</span>
    }

    /**
     * sets maximum number of threads that can generate a thumbnail at the same 
     * time.
     * To avoid excessive memory usage, the number of concurrent thumbnails
     * being generated is limited to this value.
     * By default only one thread can generate thumbnails concurrently while
     * other threads will wait until they are allowed.
     * If the server has enough memory and its load is not too high, this value
     * can be increased (especially if the hardware architecture has multiple
     * processors). Increasing this value will result in a larger throughput of
     * generated thumbnails, at the expense of a greater memory usage.
     * @param maxConcurrentThreads maximum number of concurrent threads that can
     * generate thumbnails at the same time.
     * @throws IllegalArgumentException if provided value is less than 1.
     */
    public synchronized void setMaxConcurrentThreads(int maxConcurrentThreads) 
            throws IllegalArgumentException {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if(maxConcurrentThreads &lt; MIN_CONCURRENT_THREADS) </span>
<span class="nc" id="L115">            throw new IllegalArgumentException();</span>
        
<span class="nc" id="L117">        this.mMaxConcurrentThreads = maxConcurrentThreads;</span>
<span class="nc" id="L118">    }</span>
    
    /**
     * Returns maximum number of threads that can generate a thumbnail at the 
     * same time.
     * To avoid excessive memory usage, the number of concurrent thumbnails
     * being generated is limited to this value.
     * By default only one thread can generate thumbnails concurrently while
     * other threads will wait until they are allowed.
     * If the server has enough memory and its load is not too high, this value
     * can be increased (especially if the hardware architecture has multiple
     * processors). Increasing this value will result in a larger throughput of
     * generated thumbnails, at the expense of a greater memory usage.
     * @return maximum number of threads that can generate a thumbnail at the
     * same time.
     */
    public synchronized int getMaxConcurrentThreads() {
<span class="fc" id="L135">        return mMaxConcurrentThreads;</span>
    }
    
    /**
     * Generates thumbnail of provided input file image and saves it into
     * generated thumbnail file. Information such as input image orientation can
     * be provided if it needs to be taken into account (otherwise it will be
     * ignored). Output format will determine the format of the generated image,
     * it can be used for image transcoding as well.
     * Notice that this class can only generate thumbnails having a size smaller
     * or equal than input image. Attempting to generate a larger image will
     * fail.
     * Warning: because this class is meant to be run on a server, there should
     * be limits on allowed image sizes to avoid excessive memory usage while
     * loading a very large image file.
     * @param inputImageFile input image file.
     * @param inputOrientation input image orientation (optional).
     * @param generatedThumbnailFile file where generated thumbnail will be
     * stored.
     * @param width width (in pixels) of thumbnail to be generated.
     * @param height height (in pixels) of thumbnail to be generated.
     * @param format format of image to be generated.
     * @throws IllegalArgumentException if width or height is less than minimum
     * allowed image size (1 pixel), or if width or height is greater than
     * actual image size.
     * @throws IOException  if an I/O error occurs.
     */
    public void generateAndSaveThumbnail(File inputImageFile, 
            ImageOrientation inputOrientation,
            File generatedThumbnailFile, int width, int height, 
            ThumbnailFormat format) throws IllegalArgumentException, 
            IOException {
        
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">        if(width &lt;= MIN_SIZE || height &lt;= MIN_SIZE) </span>
<span class="fc" id="L169">            throw new IllegalArgumentException();</span>
        
<span class="fc" id="L171">        synchronized (this) {</span>
            try{
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                while(mNumThreads &gt;= mMaxConcurrentThreads) wait();</span>
<span class="pc" id="L174">            }catch(InterruptedException e){}</span>
<span class="fc" id="L175">            mNumThreads++;</span>
<span class="pc" id="L176">        }</span>
        
        try {
            //default (orientation == 1)
<span class="fc" id="L180">            boolean exchangeSize = false;</span>
<span class="fc" id="L181">            int quadrants = 0;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (inputOrientation != null) {</span>
                //take into account only orientations below, other orientations
                //will be ignored
<span class="pc bfc" id="L185" title="All 4 branches covered.">                switch (inputOrientation) {</span>
                    case LEFT_BOTTOM: //orientaton == 8 (counterclockwise 90ยบ)
<span class="fc" id="L187">                        exchangeSize = true;</span>
<span class="fc" id="L188">                        quadrants = -1;</span>
<span class="fc" id="L189">                        break;</span>
                    case BOTTOM_RIGHT: //orientaton == 3 (clockwise 180ยบ)
<span class="fc" id="L191">                        exchangeSize = false;</span>
<span class="fc" id="L192">                        quadrants = -2;</span>
<span class="fc" id="L193">                        break;</span>
                    case RIGHT_TOP: //orientaton == 6 (clockwise 90ยบ)
<span class="fc" id="L195">                        exchangeSize = true;</span>
<span class="fc" id="L196">                        quadrants = -3;</span>
                }
            }
            
<span class="fc" id="L200">            int bufferedImageType = BufferedImage.TYPE_INT_RGB;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (format == ThumbnailFormat.PNG) {</span>
<span class="fc" id="L202">                bufferedImageType = BufferedImage.TYPE_INT_ARGB;</span>
            }
        
<span class="fc" id="L205">            BufferedImage inputImage = ImageIO.read(inputImageFile);</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            if (inputImage == null) {</span>
<span class="nc" id="L207">                throw new IOException();</span>
            }
            
        
            Image tempImage;
            BufferedImage resizedImage;  
            Graphics2D graphics2D;
<span class="fc bfc" id="L214" title="All 2 branches covered.">            if (exchangeSize) {</span>
<span class="pc bpc" id="L215" title="1 of 4 branches missed.">                if (width &gt; inputImage.getHeight() || </span>
                        height &gt; inputImage.getWidth()) {
<span class="fc" id="L217">                    throw new IllegalArgumentException();</span>
                }
            
                //scale image
<span class="fc" id="L221">                tempImage = inputImage.getScaledInstance(height, width, </span>
                        Image.SCALE_AREA_AVERAGING);
<span class="fc" id="L223">                resizedImage = new BufferedImage(height, width,                     </span>
                       bufferedImageType);
<span class="fc" id="L225">                graphics2D = resizedImage.createGraphics();</span>
<span class="fc" id="L226">                graphics2D.drawImage(tempImage, 0, 0, height, width, null);</span>
<span class="fc" id="L227">                graphics2D.dispose();</span>
            
            } else {
<span class="pc bpc" id="L230" title="1 of 4 branches missed.">                if (width &gt; inputImage.getWidth() || </span>
                        height &gt; inputImage.getHeight()) {
<span class="fc" id="L232">                    throw new IllegalArgumentException();</span>
                }
            
                //scale image
<span class="fc" id="L236">                tempImage = inputImage.getScaledInstance(width, height,</span>
                        Image.SCALE_AREA_AVERAGING);
<span class="fc" id="L238">                resizedImage = new BufferedImage(width, height,                     </span>
                       bufferedImageType);
<span class="fc" id="L240">                graphics2D = resizedImage.createGraphics();</span>
<span class="fc" id="L241">                graphics2D.drawImage(tempImage, 0, 0, width, height, null);</span>
<span class="fc" id="L242">                graphics2D.dispose();            </span>
            }
        
        
            double centerX, centerY;
            int resizedHeight;
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (exchangeSize) {</span>
<span class="fc" id="L249">                centerX = (double)height / 2.0;</span>
<span class="fc" id="L250">                centerY = (double)width / 2.0;            </span>
<span class="fc" id="L251">                resizedHeight = width;</span>
            } else {
<span class="fc" id="L253">                centerX = (double)width / 2.0;</span>
<span class="fc" id="L254">                centerY = (double)height / 2.0;</span>
<span class="fc" id="L255">                resizedHeight = height;</span>
            }
                                
<span class="fc" id="L258">            BufferedImage thumbnailImage = resizedImage;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">            if (quadrants != 0) {</span>
                //set rotation transformationby the desired number of quadrants
<span class="fc" id="L261">                AffineTransform rotateT = new AffineTransform();</span>
<span class="fc" id="L262">                rotateT.rotate(0.5 * Math.PI * (double)quadrants,</span>
                        centerX, centerY);
            
                //find proper translations to ensure that rotation doesn't cut 
                //off any image data            
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (quadrants != -2) {</span>
<span class="fc" id="L268">                    AffineTransform rotateT2 = new AffineTransform();</span>
<span class="fc" id="L269">                    rotateT2.rotate(-1.5 * Math.PI, centerX, centerY);</span>
<span class="fc" id="L270">                    Point2D p2din = new Point2D.Double(0.0, 0.0);</span>
<span class="fc" id="L271">                    Point2D p2dout = rotateT2.transform(p2din, null);</span>
<span class="fc" id="L272">                    double ytrans = p2dout.getY();</span>
            
<span class="fc" id="L274">                    p2din = new Point2D.Double(0.0, resizedHeight);</span>
<span class="fc" id="L275">                    p2dout = rotateT2.transform(p2din, null);</span>
<span class="fc" id="L276">                    double xtrans = p2dout.getX();</span>
            
<span class="fc" id="L278">                    AffineTransform translateT = new AffineTransform();</span>
<span class="fc" id="L279">                    translateT.translate(-xtrans, -ytrans);</span>
                                                
<span class="fc" id="L281">                    rotateT.preConcatenate(translateT);        </span>
                }
            
                //instantiate image that will contain the thumbnail
<span class="fc" id="L285">                thumbnailImage = new BufferedImage(width, height, </span>
                       bufferedImageType);
<span class="fc" id="L287">                graphics2D = thumbnailImage.createGraphics();  </span>
                //transform filtered image with scaling and rotation
<span class="fc" id="L289">                graphics2D.drawImage(resizedImage, rotateT, null);</span>
<span class="fc" id="L290">                graphics2D.dispose();</span>
            }
        
        
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            if (!ImageIO.write(thumbnailImage, format.getValue(), </span>
                    generatedThumbnailFile)) {
<span class="nc" id="L296">                throw new IOException(); //if format is not supported</span>
            }
        } finally {
            //decrease counter of threads no matter if thumbnail generation 
            //fails
<span class="fc" id="L301">            synchronized (this) {</span>
<span class="fc" id="L302">                mNumThreads--;</span>
<span class="fc" id="L303">                this.notifyAll();</span>
<span class="pc" id="L304">            }            </span>
<span class="fc" id="L305">        }</span>
<span class="fc" id="L306">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>